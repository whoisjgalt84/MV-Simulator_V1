<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Mechanical Ventilator Simulator (VC‑CMV • PC‑CMV • PC‑CSV)</title>
<meta name="description" content="Ventilator simulator with VC‑CMV, PC‑CMV, PC‑CSV, waveforms/loops, lung & effort models, freeze cursor, I:E diagnostics, alarms with audio & silence, and Pplat retention. Single‑file, no backend." />
<style>
  :root{
    --bg:#0b0c10; --panel:#121420; --panel2:#171a26; --ink:#ecf0ff; --muted:#9aa3bd; --brand:#78a8ff; --brand2:#39c6b4; --ok:#2fb67c; --warn:#f7b267; --danger:#ff6b6b; --rad:16px; --shadow:0 10px 30px rgba(0,0,0,.35);
  }
  .light:root, .light body{ --bg:#fbfbfe; --panel:#ffffff; --panel2:#f3f6ff; --ink:#0c1222; --muted:#4a5270; --brand:#2b5cff; --brand2:#06a89f; --ok:#22a56e; --warn:#ffb763; --danger:#ff6b6b; --shadow:0 10px 30px rgba(0,0,0,.08); }
  *{ box-sizing:border-box }
  html,body{ height:100% }
  body{ margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial; background:var(--bg); color:var(--ink); }
  header{ position:sticky; top:0; z-index:60; background: linear-gradient(180deg, rgba(0,0,0,.35), rgba(0,0,0,0)), var(--panel); border-bottom:1px solid rgba(255,255,255,.08); backdrop-filter: blur(8px); }
  .wrap{ max-width:1200px; margin:0 auto; padding:10px 16px; }
  .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap }
  .spacer{ flex:1 }
  .logo{ width:32px; height:32px; border-radius:50%; background: radial-gradient(circle at 30% 30%, var(--brand), var(--brand2)); box-shadow: inset 0 0 18px rgba(255,255,255,.25), 0 0 0 3px rgba(255,255,255,.05); }
  h1{ font-size:18px; margin:0; letter-spacing:.2px }

  /* Inputs & buttons */
  select, input[type="number"], input[type="text"]{ background:var(--panel2); color:var(--ink) !important; border:1px solid rgba(255,255,255,.15); border-radius:10px; padding:8px 10px; }
  .btn{ appearance:none; border:1px solid rgba(255,255,255,.12); background:var(--panel2); color:var(--ink); padding:8px 12px; border-radius:10px; font-weight:800; cursor:pointer; box-shadow:var(--shadow); }
  .btn.primary{ background: linear-gradient(180deg, var(--brand), var(--brand2)); border-color:transparent; color:white }
  .toolbar .btn{ font-weight:700 }

  main{ max-width:1200px; margin:0 auto; padding:12px 16px; display:grid; grid-template-columns: 260px 1fr; gap:12px }
  @media (max-width: 980px){ main{ grid-template-columns: 1fr } }
  .fullRow{ grid-column: 1 / -1; }
  aside{ background:var(--panel); border:1px solid rgba(255,255,255,.08); border-radius:var(--rad); padding:12px; position:sticky; top:78px; height:fit-content; align-self:start }
  aside h3{ margin:6px 0 8px; font-size:13px; color:var(--muted); text-transform:uppercase; letter-spacing:1.1px }
  aside .group{ display:grid; gap:8px; margin-bottom:10px }
  .pair{ display:grid; grid-template-columns: 1fr 120px; gap:8px; align-items:center }
  .pair label{ font-size:12px; color:var(--muted) }
  .pair input[type="range"]{ width:100% }

  .card{ background:var(--panel); border:1px solid rgba(255,255,255,.08); border-radius:var(--rad); box-shadow:var(--shadow); overflow:hidden }
  .card .head{ display:flex; gap:10px; align-items:center; padding:10px 12px; border-bottom:1px solid rgba(255,255,255,.06) }
  .card .head h2{ margin:0; font-size:14px }
  .card .body{ padding:10px 12px }

  /* Top ribbon table */
  .grid{ display:grid; grid-template-columns: repeat(8, minmax(130px, 1fr)); gap:8px; }
  .grid.narrow{ grid-template-columns: repeat(6, minmax(130px, 1fr)); }
  .stat{ background:var(--panel2); border:1px solid rgba(255,255,255,.08); border-radius:12px; padding:8px 10px }
  .stat .k{ font-size:11px; color:var(--muted) }
  .stat .v{ font-weight:900; font-size:18px }
  .unit{ font-size:11px; color:var(--muted); margin-left:6px }

  /* Waveforms / Loops */
  #waveWrap{ background:var(--panel); border:1px solid rgba(255,255,255,.08); border-radius:var(--rad); padding:8px; position:relative }
  .wave{ display:grid; grid-template-columns: 60px 1fr; align-items:center; gap:8px; padding:6px 0; position:relative }
  .yaxis{ color:var(--muted); font-size:12px; text-align:right; padding-right:4px; min-width:60px }
  canvas{ width:100%; height:120px; background:linear-gradient(180deg, rgba(255,255,255,.02), rgba(255,255,255,0)); border-radius:8px; }
  .xlabels{ position:absolute; left:60px; right:0; bottom:2px; display:flex; justify-content:space-between; font-size:11px; color:var(--muted); pointer-events:none }
  .hidden{ display:none !important }

  /* Control surface with buttons + rotary knob */
  .controlsWrap{ display:grid; grid-template-columns: 1fr 160px; gap:12px; align-items:stretch }
  .btnGrid{ display:grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap:8px }
  .paramBtn{ border:1px solid rgba(255,255,255,.12); background:var(--panel2); border-radius:12px; padding:10px; text-align:left; cursor:pointer; display:grid; gap:4px; color:var(--ink) }
  .paramBtn .lbl{ font-size:12px; color:var(--muted) }
  .paramBtn .val{ font-weight:900; font-size:20px; color:var(--brand); text-shadow:0 0 8px rgba(120,168,255,.25) }
  .paramBtn.active{ outline: 2px solid var(--brand); border-color: transparent; }
  .dial{ background:var(--panel2); border:1px solid rgba(255,255,255,.12); border-radius:16px; padding:10px; display:grid; gap:10px; justify-items:center }
  .knob{ width:120px; height:120px; border-radius:999px; background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.15), rgba(255,255,255,.02)); display:grid; place-items:center; position:relative; box-shadow: inset 0 6px 18px rgba(0,0,0,.35); }
  .knob::after{ content:""; width:6px; height:28px; background: var(--brand2); border-radius:3px; position:absolute; top:12px; left:50%; transform: translateX(-50%); box-shadow: 0 0 10px rgba(0,0,0,.4); }
  .dial .readout{ font-weight:900; font-size:20px; color:var(--brand2) }
  .dial .hint{ font-size:11px; color:var(--muted) }
  .dial .row{ display:flex; gap:8px }
  .dial button{ padding:8px 10px }

  footer{ text-align:center; color:var(--muted); font-size:12px; padding:20px 10px 40px }

  /* Collapsible */
  details{ background:var(--panel); border:1px solid rgba(255,255,255,.08); border-radius:12px; padding:8px 10px }
  details summary{ cursor:pointer; font-weight:700 }

  .ie-box{ display:flex; gap:8px; align-items:center; font-size:12px; color:var(--muted) }

  /* Freeze badge */
  #freezeBadge{ position:absolute; top:8px; right:10px; font-size:11px; color:white; background:linear-gradient(180deg, #e76f51,#f4a261); padding:4px 8px; border-radius:999px; display:none; }
  #freezeBadge.on{ display:inline-block; }

  /* Snap toggle */
  #snapBtn, #loopsBtn{ margin-left:8px }

  /* Alarm bar */
  #alarmBar{ display:flex; align-items:center; gap:10px; padding:6px 12px; border-radius:12px; border:1px solid rgba(255,255,255,.12); box-shadow:var(--shadow); min-height:34px; }
  #alarmText{ font-weight:800; letter-spacing:.2px }
  #alarmBar.ok{ background:linear-gradient(180deg, rgba(47,182,124,.35), rgba(47,182,124,.25)); border-color:rgba(47,182,124,.45) }
  #alarmBar.active{ background:linear-gradient(180deg, rgba(255,107,107,.75), rgba(255,107,107,.45)); border-color:rgba(255,107,107,.85) }
  #alarmBar.silenced{ background:linear-gradient(180deg, rgba(247,178,103,.7), rgba(247,178,103,.45)); border-color:rgba(247,178,103,.85) }
  #silenceBtn{ display:none }
  #alarmBar.active #silenceBtn, #alarmBar.silenced #silenceBtn{ display:inline-flex }
</style>
</head>
<body>
<header>
  <div class="wrap row">
    <div class="logo" aria-hidden="true"></div>
    <h1>Mechanical Ventilator Simulator</h1>
    <span class="spacer"></span>
    <div class="toolbar row">
      <label class="row" style="gap:6px; align-items:center">
        <span style="font-size:12px;color:var(--muted)">Mode</span>
        <select id="mode">
          <option>VC-CMV</option>
          <option>PC-CMV</option>
          <option>PC-CSV</option>
        </select>
      </label>
      <label class="row" style="gap:6px; align-items:center">
        <span style="font-size:12px;color:var(--muted)">Patient</span>
        <select id="patient">
          <option>Adult</option>
          <option>Pediatric</option>
          <option>Infant</option>
        </select>
      </label>
      <button class="btn" id="freezeBtn" title="Freeze/unfreeze the scrolling waveforms">Freeze</button>
      <button class="btn" id="themeBtn" title="Toggle theme">Theme</button>
      <button class="btn" id="resetBtn" title="Reset to defaults">Reset</button>
      <button class="btn" id="holdBtn" title="Inspiratory Hold / Plateau">Hold</button>
      <button class="btn primary" id="helpBtn" title="Help">Help</button>
    </div>
  </div>
</header>

<main>
  <div class="fullRow" id="alarmBar" class="ok">
    <span id="alarmText"></span>
    <span class="spacer"></span>
    <button class="btn" id="silenceBtn" title="Silence alarm for 60 s">Silence</button>
  </div>

  <aside>
    <h3>Time Window</h3>
    <div class="pair">
      <label for="win">Display window (10–90 s)</label>
      <input id="win" type="range" min="10" max="90" step="1" value="30" />
    </div>

    <details open>
      <summary>Lung Model</summary>
      <div class="group" style="margin-top:8px">
        <div class="pair"><label>Compliance (L/cmH<sub>2</sub>O)</label><input id="C" type="number" min="0.0" max="100" step="0.001" value="0.05"></div>
        <input id="C_r" type="range" min="0.000" max="0.200" step="0.001" value="0.050" oninput="C.value=this.value">
        <div class="pair"><label>Resistance (cmH<sub>2</sub>O/L/s)</label><input id="R" type="number" min="0" max="100" step="0.1" value="10"></div>
        <input id="R_r" type="range" min="0" max="60" step="0.5" value="10" oninput="R.value=this.value">
        <div class="pair"><label>Leak (L/min)</label><input id="Leak" type="number" min="0" max="30" step="0.5" value="0"></div>
        <input id="Leak_r" type="range" min="0" max="30" step="0.5" value="0" oninput="Leak.value=this.value">
      </div>
    </details>

    <details>
      <summary>Effort Model</summary>
      <div class="group" style="margin-top:8px">
        <div class="pair"><label>Patient Frequency</label><input id="effF" type="number" min="0" max="40" step="1" value="0"></div>
        <input id="effF_r" type="range" min="0" max="40" step="1" value="0" oninput="effF.value=this.value">
        <div class="pair"><label>Delay Before Effort (s)</label><input id="effDelay" type="number" min="0" max="5" step="0.05" value="0.00"></div>
        <input id="effDelay_r" type="range" min="0" max="5" step="0.05" value="0.00" oninput="effDelay.value=this.value">
        <div class="pair"><label>Duration of Effort (s)</label><input id="effDur" type="number" min="0" max="5" step="0.05" value="0.0"></div>
        <input id="effDur_r" type="range" min="0" max="5" step="0.05" value="0.0" oninput="effDur.value=this.value">
        <div class="pair"><label>Max Pmus (cmH<sub>2</sub>O)</label><input id="pmusMax" type="number" min="0" max="30" step="0.5" value="0"></div>
        <input id="pmusMax_r" type="range" min="0" max="30" step="0.5" value="0" oninput="pmusMax.value=this.value">
      </div>
    </details>

    <details>
      <summary>Alarms</summary>
      <div class="group" style="margin-top:8px">
        <div class="pair"><label>High (PPEAK) cmH<sub>2</sub>O</label><input id="a_highPpeak" type="number" min="0" max="100" step="1" value="40"></div>
        <input id="a_highPpeak_r" type="range" min="0" max="100" step="1" value="40" oninput="a_highPpeak.value=this.value">
        <div class="pair"><label>High (VTE) mL</label><input id="a_highVte" type="number" min="30" max="1000" step="10" value="800"></div>
        <input id="a_highVte_r" type="range" min="30" max="1000" step="10" value="800" oninput="a_highVte.value=this.value">
        <div class="pair"><label>Low (VTE) mL</label><input id="a_lowVte" type="number" min="5" max="600" step="5" value="150"></div>
        <input id="a_lowVte_r" type="range" min="5" max="600" step="5" value="150" oninput="a_lowVte.value=this.value">
        <div class="pair"><label>High (FTOT) Breaths/min</label><input id="a_highFtot" type="number" min="10" max="60" step="1" value="35"></div>
        <input id="a_highFtot_r" type="range" min="10" max="60" step="1" value="35" oninput="a_highFtot.value=this.value">
        <div class="pair"><label>Low (VE TOT) L/min</label><input id="a_lowVe" type="number" min="0" max="30" step="0.5" value="3"></div>
        <input id="a_lowVe_r" type="range" min="0" max="30" step="0.5" value="3" oninput="a_lowVe.value=this.value">
        <div class="pair"><label>Apnea Interval (s)</label><input id="a_apnea" type="number" min="0" max="60" step="1" value="20"></div>
        <input id="a_apnea_r" type="range" min="0" max="60" step="1" value="20" oninput="a_apnea.value=this.value">
      </div>
    </details>

    <p class="ie-box">I:E <span id="ieVal" style="font-weight:800; margin-left:6px">1:2</span></p>
  </aside>

  <section class="content">
    <div class="card">
      <div class="head"><h2>Ventilator Outputs</h2></div>
      <div class="body grid" id="stats"></div>
    </div>

    <div class="card">
      <div class="head"><h2>I:E Diagnostics</h2><span class="spacer"></span><small style="color:var(--muted)">Measured from breath timings</small></div>
      <div class="body grid narrow" id="ieDiag"></div>
    </div>

    <div id="waveWrap" class="card">
      <div class="head"><h2>Display</h2><span class="spacer"></span><small style="color:var(--muted)">Time series or loops • Freeze to measure • <b>Snap</b> finds nearby peaks/valleys</small><button class="btn" id="loopsBtn" title="Toggle loops view (PV & FV)">Loops: Off</button><button class="btn" id="snapBtn" title="Toggle snap to nearest extrema (hold Shift while moving)">Snap: Off</button></div>
      <div class="body">
        <div id="freezeBadge">Frozen</div>
        <div class="wave" id="rowP">
          <div class="yaxis" id="yP">Pressure<br><span style="font-size:10px">(cmH<sub>2</sub>O)</span></div>
          <canvas id="pCanvas" height="120"></canvas>
          <div class="xlabels" id="pXLabels"></div>
        </div>
        <div class="wave" id="rowF">
          <div class="yaxis" id="yF">Flow<br><span style="font-size:10px">(L/s)</span></div>
          <canvas id="fCanvas" height="120"></canvas>
          <div class="xlabels" id="fXLabels"></div>
        </div>
        <div class="wave" id="rowV">
          <div class="yaxis" id="yV">Volume<br><span style="font-size:10px">(mL)</span></div>
          <canvas id="vCanvas" height="120"></canvas>
          <div class="xlabels" id="vXLabels"></div>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="head"><h2>Controls — <span id="modeLabel">VC‑CMV</span></h2></div>
      <div class="body">
        <div class="controlsWrap">
          <div id="btnGrid" class="btnGrid"></div>
          <div class="dial">
            <div class="knob" id="knob" title="Drag up/down or scroll to adjust"></div>
            <div class="readout" id="dialValue">—</div>
            <div class="hint" id="dialLabel">Select a control button</div>
            <div class="row">
              <button class="btn" id="decrBtn">−</button>
              <button class="btn" id="incrBtn">+</button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <details>
      <summary>Help</summary>
      <div class="card" style="margin-top:10px">
        <div class="body">
          <p>This educational simulator approximates single‑compartment lung mechanics. <em>VC‑CMV</em> uses set flow (square or ramp) to deliver set VT; pressure results from resistance and compliance. <em>PC‑CMV</em> uses set inspiratory pressure and time; flow and volume are results. <em>PC‑CSV</em> models pressure support with patient effort and cycles off when inspiratory flow decays to the chosen threshold. Tap <b>Freeze</b> to stop the scroller and move your pointer across the waveforms to sample values. Hold <b>Shift</b> or toggle <b>Snap</b> to jump to nearby peaks/valleys.</p>
          <p>Use <b>Hold</b> to request a one‑shot inspiratory pause; the simulator captures plateau pressure during the hold. If <b>Pause Time (TPL) > 0</b>, plateau pressure is also captured each breath automatically. <b>Auto‑PEEP</b> is detected as the residual alveolar pressure above set PEEP at end‑expiration.</p>
        </div>
      </div>
    </details>

    <footer>Single‑file • No backend • © Ventilator Simulator</footer>
  </section>
</main>

<script>
// ---------- Utilities ----------
const $ = (s, el=document)=> el.querySelector(s);
const $$ = (s, el=document)=> Array.from(el.querySelectorAll(s));
function clamp(v, lo, hi){ return Math.max(lo, Math.min(hi, v)); }
function fmt(n, d=1){ if(!isFinite(n)) return '—'; return Number(n).toFixed(d); }
function now(){ return performance.now()/1000; }
function lerp(a,b,t){ return a + (b-a)*t; }

// ---------- Global State ----------
const state = {
  mode: 'VC-CMV',
  patient: 'Adult',
  // Lung model (defaults per request)
  C: 0.05,   // L/cmH2O
  R: 10,     // cmH2O/L/s
  Leak: 0,   // L/min
  // Effort defaults per request
  effF: 0,   // breaths/min
  effDelay: 0.00,
  effDur: 0.0,
  pmusMax: 0,
  // VC‑CMV defaults per request
  VC: {
    F: 12,            // bpm
    VT: 500,          // mL
    VMAX: 60,         // L/min (peak for Ramp; constant for Square)
    O2: 40,           // %
    PEEP: 5,          // cmH2O
    TPL: 0.0,         // s
    flowWave: 'Square'// 'Square' | 'Ramp'
  },
  // PC‑CMV
  PC: {
    F: 16,            // bpm
    PINSP: 18,        // cmH2O above PEEP
    ITIME: 1.0,       // s
    PEEP: 5,          // cmH2O
    TPL: 0.2,         // s
    O2: 40            // %
  },
  // PC‑CSV
  PSV: {
    VCycle: 30,       // % (flow cycle threshold)
    PEEP: 5,          // cmH2O
    PS: 12,           // cmH2O
    O2: 30,           // %
    PSlope: 0.15,     // s (rise time)
    TrigType: 'Flow', // 'Flow' | 'Pressure'
    TrigFlow: 2,      // L/min
    TrigPress: 1      // cmH2O
  },
  alarms: {
    highPpeak: 40,
    highVte: 800,
    lowVte: 150,
    highFtot: 35,
    lowVe: 3,
    apnea: 20
  },
  loops: { on:false }
};

const defaultState = JSON.parse(JSON.stringify(state));

// Patient presets (kept typical), only applied when user changes patient
const presets = {
  'Adult':   { C: 0.06, R: 10 },
  'Pediatric': { C: 0.02, R: 20 },
  'Infant':  { C: 0.006, R: 30 }
};

// ---------- Controls surface (buttons + rotary) ----------
const controlsSpec = {
  'VC-CMV': [
    { key:'F', label:'Frequency F', unit:'Breaths/min', min:1, max:100, step:1, type:'number' },
    { key:'VT', label:'Tidal Volume VT', unit:'mL', min:50, max:1000, step:10, type:'number' },
    { key:'VMAX', label:'Inspiratory Flow VMAX', unit:'L/min', min:1, max:100, step:1, type:'number' },
    { key:'PEEP', label:'PEEP', unit:'cmH2O', min:0, max:50, step:1, type:'number' },
    { key:'TPL', label:'Pause Time', unit:'sec', min:0.0, max:1.0, step:0.05, type:'number' },
    { key:'flowWave', label:'Flow Waveform', unit:'', options:['Ramp','Square'], type:'select' },
    { key:'O2', label:'FiO2', unit:'%', min:21, max:100, step:1, type:'number' }
  ],
  'PC-CMV': [
    { key:'F', label:'Frequency F', unit:'Breaths/min', min:1, max:100, step:1, type:'number' },
    { key:'PINSP', label:'Pinsp (above PEEP)', unit:'cmH2O', min:1, max:50, step:1, type:'number' },
    { key:'ITIME', label:'Inspiratory Time', unit:'sec', min:0.1, max:3.0, step:0.05, type:'number' },
    { key:'PEEP', label:'PEEP', unit:'cmH2O', min:0, max:50, step:1, type:'number' },
    { key:'TPL', label:'Pause Time', unit:'sec', min:0.0, max:1.0, step:0.05, type:'number' },
    { key:'O2', label:'FiO2', unit:'%', min:21, max:100, step:1, type:'number' }
  ],
  'PC-CSV': [
    { key:'VCycle', label:'Flow Cycle Threshold', unit:'%', min:0, max:100, step:1, type:'number' },
    { key:'PEEP', label:'PEEP', unit:'cmH2O', min:0, max:50, step:1, type:'number' },
    { key:'PS', label:'Pressure Support', unit:'cmH2O', min:0, max:50, step:1, type:'number' },
    { key:'PSlope', label:'Pressure Rise Time', unit:'sec', min:0.0, max:5.0, step:0.05, type:'number' },
    { key:'TrigType', label:'Trigger Type', unit:'', options:['Flow','Pressure'], type:'select' },
    { key:'TrigFlow', label:'Flow Trigger', unit:'L/min', min:0.1, max:10, step:0.1, type:'number' },
    { key:'TrigPress', label:'Pressure Trigger', unit:'cmH2O', min:0.2, max:10, step:0.1, type:'number' },
    { key:'O2', label:'FiO2', unit:'%', min:21, max:100, step:1, type:'number' }
  ]
};

let selected = null; // {modeKey, key, spec}

function renderControls(){
  $('#modeLabel').textContent = state.mode.replace('-', '‑');
  const grid = $('#btnGrid'); grid.innerHTML='';
  const spec = controlsSpec[state.mode];
  const src = state.mode==='VC-CMV'? state.VC : state.mode==='PC-CMV'? state.PC : state.PSV;
  spec.forEach(s=>{
    const b = document.createElement('button'); b.type='button'; b.className='paramBtn';
    b.dataset.key = s.key;
    b.innerHTML = `<div class="lbl">${s.label}${s.unit?` <span class=\"unit\">(${s.unit})</span>`:''}</div><div class="val" id="val_${s.key}">—</div>`;
    b.onclick = ()=> { $$('.paramBtn').forEach(x=>x.classList.remove('active')); b.classList.add('active'); selected={ modeKey: state.mode, key: s.key, spec: s }; updateDialLabel(); };
    grid.appendChild(b);
  });
  const firstBtn = grid.querySelector('.paramBtn'); if(firstBtn){ firstBtn.click(); }
  refreshButtonValues();
}

function refreshButtonValues(){
  const src = state.mode==='VC-CMV'? state.VC : state.mode==='PC-CMV'? state.PC : state.PSV;
  const spec = controlsSpec[state.mode];
  spec.forEach(s=>{
    const v = src[s.key]; const el = $('#val_'+s.key); if(!el) return;
    const text = (s.type==='select') ? String(v) : (s.unit==='%'? fmt(v,0): s.unit==='sec'? fmt(v,2): fmt(v, s.step<1?1:0));
    el.textContent = `${text}${s.type==='select'?'':' '}`;
  });
}

function nudgeSelected(delta){
  if(!selected) return;
  const src = state.mode==='VC-CMV'? state.VC : state.mode==='PC-CMV'? state.PC : state.PSV;
  const s = selected.spec;
  if (s.type==='select'){
    const idx = s.options.indexOf(src[s.key]);
    const next = clamp(idx + (delta>0?1:-1), 0, s.options.length-1);
    src[s.key] = s.options[next];
  } else {
    const step = Number(s.step||1);
    const min = Number(s.min ?? -Infinity), max = Number(s.max ?? Infinity);
    let val = Number(src[s.key]);
    val = val + delta*step;
    val = Math.round(val/step)*step;
    val = clamp(val, min, max);
    src[s.key] = Number(val);
  }
  updateDialLabel(); refreshButtonValues();
}

function updateDialLabel(){
  if(!selected){ $('#dialLabel').textContent='Select a control button'; $('#dialValue').textContent='—'; return; }
  const src = state.mode==='VC-CMV'? state.VC : state.mode==='PC-CMV'? state.PC : state.PSV;
  const val = src[selected.key];
  $('#dialLabel').textContent = selected.spec.label;
  $('#dialValue').textContent = (selected.spec.type==='select')? val : fmt(val, selected.spec.step<1?1:0);
}

(function(){
  const knob = $('#knob');
  let dragging=false, lastY=0;
  knob.addEventListener('pointerdown', (e)=>{ dragging=true; lastY=e.clientY; knob.setPointerCapture(e.pointerId); });
  knob.addEventListener('pointermove', (e)=>{ if(!dragging) return; const dy = lastY - e.clientY; lastY = e.clientY; nudgeSelected(Math.sign(dy)); });
  knob.addEventListener('pointerup', ()=> dragging=false);
  knob.addEventListener('wheel', (e)=>{ e.preventDefault(); nudgeSelected(e.deltaY<0?+1:-1); }, {passive:false});
  $('#incrBtn').onclick = ()=> nudgeSelected(+1);
  $('#decrBtn').onclick = ()=> nudgeSelected(-1);
})();

// Mode/Patient/Theme/Reset/Help/Freeze/Snap/Loops
$('#mode').addEventListener('change', (e)=>{ state.mode = e.target.value; renderControls(); });
$('#patient').addEventListener('change', (e)=>{ state.patient = e.target.value; const p=presets[state.patient]; state.C=p.C; state.R=p.R; $('#C').value=p.C; $('#C_r').value=p.C; $('#R').value=p.R; $('#R_r').value=p.R; });
$('#themeBtn').onclick = ()=> document.body.classList.toggle('light');
function syncInputs(){ $('#C').value=state.C; $('#C_r').value=state.C; $('#R').value=state.R; $('#R_r').value=state.R; $('#Leak').value=state.Leak; $('#Leak_r').value=state.Leak; $('#effF').value=state.effF; $('#effF_r').value=state.effF; $('#effDelay').value=state.effDelay; $('#effDelay_r').value=state.effDelay; $('#effDur').value=state.effDur; $('#effDur_r').value=state.effDur; $('#pmusMax').value=state.pmusMax; $('#pmusMax_r').value=state.pmusMax; }
$('#resetBtn').onclick = ()=>{ Object.assign(state, JSON.parse(JSON.stringify(defaultState))); syncInputs(); renderControls(); };
$('#helpBtn').onclick = ()=> alert('Use the mode menu and buttons to select a control. Turn the rotary to adjust. Waveforms can be frozen to measure values with the cursor. Hold Shift or toggle Snap to jump to nearby peaks/valleys. Lung/Effort models on the left adjust physiology. Use Hold or nonzero Pause Time to capture plateau (PPL).');
$('#holdBtn').onclick = ()=> { hold.request = true; hold.duration = 0.5; };

const freeze = { on:false, data:null, breaths:null, t:0, win:30, cursor:{active:false, t:0, snap:false, shift:false} };
$('#freezeBtn').onclick = ()=>{
  freeze.on = !freeze.on;
  if(freeze.on){ freeze.data = sim.log.map(d=>({...d})); freeze.breaths = sim.breaths.map(b=>({...b})); freeze.t = sim.t; freeze.win = Number($('#win').value); $('#freezeBadge').classList.add('on'); $('#freezeBtn').textContent='Unfreeze'; }
  else{ freeze.data=null; freeze.breaths=null; $('#freezeBadge').classList.remove('on'); $('#freezeBtn').textContent='Freeze'; freeze.cursor.active=false; }
};
$('#snapBtn').onclick = ()=>{ freeze.cursor.snap = !freeze.cursor.snap; $('#snapBtn').textContent = 'Snap: ' + (freeze.cursor.snap? 'On':'Off'); };
$('#loopsBtn').onclick = ()=>{ state.loops.on = !state.loops.on; $('#loopsBtn').textContent = 'Loops: ' + (state.loops.on?'On':'Off'); };
window.addEventListener('keydown', (e)=>{ if(e.key==='Shift') freeze.cursor.shift=true; });
window.addEventListener('keyup', (e)=>{ if(e.key==='Shift') freeze.cursor.shift=false; });

['C','R','Leak','effF','effDelay','effDur','pmusMax'].forEach(id=>{ $('#'+id).addEventListener('change', (e)=>{ state[id]= Number(e.target.value); }); });
['C_r','R_r','Leak_r','effF_r','effDelay_r','effDur_r','pmusMax_r'].forEach(id=>{ $('#'+id).addEventListener('input', (e)=>{ const base=id.replace(/_r$/,''); $('#'+base).value=e.target.value; state[base]=Number(e.target.value); }); });

// Alarm inputs
['a_highPpeak','a_highVte','a_lowVte','a_highFtot','a_lowVe','a_apnea'].forEach(id=>{
  $('#'+id).addEventListener('change', (e)=>{ const k=id.replace('a_',''); state.alarms[k]= Number(e.target.value); });
});
['a_highPpeak_r','a_highVte_r','a_lowVte_r','a_highFtot_r','a_lowVe_r','a_apnea_r'].forEach(id=>{
  $('#'+id).addEventListener('input', (e)=>{ const base=id.replace(/_r$/,''); $('#'+base).value=e.target.value; const k=base.replace('a_',''); state.alarms[k]= Number(e.target.value); });
});

renderControls();
syncInputs();

// ---------- Simulation Engine ----------
const pCan = $('#pCanvas'), fCan=$('#fCanvas'), vCan=$('#vCanvas');
const ctxP = pCan.getContext('2d'); const ctxF = fCan.getContext('2d'); const ctxV = vCan.getContext('2d');

let tPrev = now();
let sim = {
  t: 0, dt: 0.01,
  V: 0, Paw: 0, Flow: 0,
  phase: 'exp', timeInPhase: 0, cycleStart: 0, csvPeakFlow: 0,
  pauseRemaining: 0,
  breaths: [], // {start, expStart, cycleEnd, VT (L), VTE (L), Ti, Te, Ppeak, Pplat, autoPEEP}
  log: []
};

const hold = { request:false, duration:0.5, active:false, remaining:0 };
let lastPplatSeen = null; // persists until overwritten

function finalizePreviousBreath(){
  const prev = sim.breaths[sim.breaths.length-1];
  if(!prev || prev.cycleEnd) return;
  prev.cycleEnd = sim.t;
  if(prev.expStart!=null){ prev.Te = Math.max(0, prev.cycleEnd - prev.expStart); }
  const Palv_end = sim.V / Math.max(1e-6, state.C);
  prev.autoPEEP = Math.max(0, Palv_end);
}

function startNewBreath(){
  finalizePreviousBreath();
  sim.phase='insp'; sim.timeInPhase=0; sim.cycleStart=sim.t; sim.csvPeakFlow=0; sim.pauseRemaining=0; hold.active=false; hold.remaining=0;
  sim.breaths.push({ start: sim.t, expStart:null, cycleEnd:null, VT:0, VTE:0, Ti:0, Te:0, Ppeak:0, Pplat:lastPplatSeen, autoPEEP:0 });
}

function currentBreath(){ return sim.breaths[sim.breaths.length-1]; }

function pmusAt(t){
  const f = clamp(state.effF,0,40); if(f<=0) return 0; const T = 60/Math.max(0.1,f);
  const m = (t % T); const start = clamp(state.effDelay,0,T); const dur = clamp(state.effDur,0,T);
  if(m < start || m > start+dur || dur<=0) return 0; const x = (m - start) / Math.max(1e-6,dur);
  return state.pmusMax * Math.sin(Math.PI * x);
}

function simStep(){
  const C = Math.max(1e-6, state.C); const R = Math.max(1e-6, state.R); const leakLps = Math.max(0, state.Leak)/60;
  const PEEPset = (state.mode==='VC-CMV'? state.VC.PEEP : state.mode==='PC-CMV'? state.PC.PEEP : state.PSV.PEEP);
  const Pmus = pmusAt(sim.t);

  if (state.mode==='VC-CMV'){
    const M = state.VC; const Tcycle = 60/Math.max(1,M.F);
    const VT_L = M.VT/1000; const Vinsp_peak = Math.max(0.01, M.VMAX/60);
    const Ti_nom = (M.flowWave==='Square') ? (VT_L / Vinsp_peak) : (2*VT_L)/Vinsp_peak; const Ti_eff = Math.min(Math.max(0.1, Ti_nom), Tcycle);

    if(sim.phase==='exp' && (sim.t - sim.cycleStart) >= (Tcycle)) startNewBreath();

    if(sim.phase==='insp' && sim.timeInPhase >= Ti_eff){
      sim.phase='pause'; sim.timeInPhase=0; currentBreath().Ti = Ti_eff; // pure inspiratory time
      if(hold.request){ hold.request=false; hold.active=true; hold.remaining = hold.duration; sim.pauseRemaining = hold.remaining; }
      else { sim.pauseRemaining = clamp(M.TPL, 0, Math.max(0, Tcycle-Ti_eff-0.05)); }
    }
    else if(sim.phase==='pause'){
      sim.Flow = 0; const Palv = (sim.V/C) - Pmus; sim.Paw = PEEPset + Palv; sim.V = Math.max(0, sim.V - leakLps*sim.dt);
      // Capture plateau either via Hold or non-zero TPL each breath
      if(hold.active){ hold.remaining = Math.max(0, hold.remaining - sim.dt); if(hold.remaining<=0){ hold.active=false; currentBreath().Pplat = sim.Paw; lastPplatSeen = sim.Paw; } }
      sim.pauseRemaining = Math.max(0, sim.pauseRemaining - sim.dt);
      if(sim.pauseRemaining<=0){ currentBreath().Pplat = sim.Paw; lastPplatSeen = sim.Paw; sim.phase='exp'; sim.timeInPhase=0; currentBreath().expStart = sim.t; }
    }
    else if(sim.phase==='insp'){
      let targetFlow = (M.flowWave==='Square') ? Vinsp_peak : Math.max(0, Vinsp_peak * (1 - sim.timeInPhase/(Ti_eff||1)));
      sim.Flow = targetFlow; const Palv = (sim.V/C) - Pmus; const Pres = sim.Flow * R; sim.Paw = PEEPset + Palv + Pres;
      sim.V = Math.max(0, sim.V + (sim.Flow - leakLps)*sim.dt); const b=currentBreath(); if(b){ b.Ppeak = Math.max(b.Ppeak||0, sim.Paw); b.VT = Math.max(b.VT||0, sim.V); }
    }
    else { // exp
      const tau = R*C; sim.V = Math.max(0, sim.V - ((sim.V/(tau||1)) + leakLps)*sim.dt); const Palv = (sim.V/C) - Pmus; sim.Flow = - ( (Palv) ) / R; sim.Paw = PEEPset + Palv + sim.Flow*R; if(currentBreath() && currentBreath().expStart!=null){ currentBreath().VTE += Math.max(0, -sim.Flow)*sim.dt; }
    }

  } else if (state.mode==='PC-CMV'){
    const M = state.PC; const Tcycle = 60/Math.max(1,M.F); const Ti = clamp(M.ITIME, 0.1, Tcycle);

    if(sim.phase==='exp' && (sim.t - sim.cycleStart) >= (Tcycle)) startNewBreath();

    if(sim.phase==='insp' && sim.timeInPhase >= Ti){
      sim.phase='pause'; sim.timeInPhase=0; currentBreath().Ti = Ti; // pure inspiratory time
      if(hold.request){ hold.request=false; hold.active=true; hold.remaining = hold.duration; sim.pauseRemaining = hold.remaining; }
      else { sim.pauseRemaining = clamp(M.TPL, 0, Math.max(0, Tcycle-Ti-0.05)); }
    }
    else if(sim.phase==='pause'){
      sim.Flow=0; const Palv=(sim.V/C) - Pmus; sim.Paw = PEEPset + Palv; sim.V=Math.max(0, sim.V - leakLps*sim.dt);
      if(hold.active){ hold.remaining=Math.max(0, hold.remaining - sim.dt); if(hold.remaining<=0){ hold.active=false; currentBreath().Pplat = sim.Paw; lastPplatSeen = sim.Paw; } }
      sim.pauseRemaining = Math.max(0, sim.pauseRemaining - sim.dt);
      if(sim.pauseRemaining<=0){ currentBreath().Pplat = sim.Paw; lastPplatSeen = sim.Paw; sim.phase='exp'; sim.timeInPhase=0; currentBreath().expStart=sim.t; }
    }
    else if(sim.phase==='insp'){
      const tauRise = 0.1; const Pvent = PEEPset + M.PINSP * (1 - Math.exp(-sim.timeInPhase/(tauRise||1e-3)));
      const Palv = (sim.V/C) - Pmus; const dP = (Pvent - (PEEPset + Palv)); sim.Flow = dP / R; sim.V = Math.max(0, sim.V + (sim.Flow - leakLps)*sim.dt); sim.Paw = Pvent; const b=currentBreath(); if(b){ b.Ppeak=Math.max(b.Ppeak||0, sim.Paw); b.VT=Math.max(b.VT||0, sim.V); }
    }
    else {
      const tau = R*C; sim.V = Math.max(0, sim.V - ((sim.V/(tau||1)) + leakLps)*sim.dt); const Palv=(sim.V/C) - Pmus; sim.Flow = - ( (Palv) ) / R; sim.Paw = PEEPset + Palv + sim.Flow*R; if(currentBreath() && currentBreath().expStart!=null){ currentBreath().VTE += Math.max(0, -sim.Flow)*sim.dt; }
    }

  } else { // PC‑CSV
    const M = state.PSV; const Vthresh = clamp(M.VCycle,0,100)/100;
    if(sim.phase==='exp'){
      const Palv = (sim.V/C) - Pmus; const flowIf = (Pmus - (sim.V/C)) / R; const flowTrig = (M.TrigFlow/60);
      const pressTrigger = (M.TrigType==='Pressure') && (Pmus >= M.TrigPress); const flowTrigger = (M.TrigType==='Flow') && (flowIf >= flowTrig);
      const refractory = 0.15; if( (sim.t - sim.cycleStart) > refractory && (flowTrigger || pressTrigger) ) startNewBreath();
      else { const tau = R*C; sim.V = Math.max(0, sim.V - ((sim.V/(tau||1)) + leakLps)*sim.dt); const Palv2=(sim.V/C) - Pmus; sim.Flow = - ( (Palv2) ) / R; sim.Paw = PEEPset + Palv2 + sim.Flow*R; if(currentBreath() && currentBreath().expStart!=null){ currentBreath().VTE += Math.max(0, -sim.Flow)*sim.dt; } }
    }
    if(sim.phase==='insp'){
      const Pvent = PEEPset + M.PS * (1 - Math.exp(-(sim.timeInPhase)/(Math.max(0.02,M.PSlope))));
      const Palv = (sim.V/C) - Pmus; const dP = (Pvent - (PEEPset + Palv)); sim.Flow = dP / R; sim.V = Math.max(0, sim.V + (sim.Flow - leakLps)*sim.dt); sim.Paw = Pvent; sim.csvPeakFlow = Math.max(sim.csvPeakFlow, sim.Flow);
      const b=currentBreath(); if(b){ b.Ppeak=Math.max(b.Ppeak||0, sim.Paw); b.VT=Math.max(b.VT||0, sim.V); }
      if(sim.timeInPhase>0.15 && sim.Flow <= sim.csvPeakFlow * Vthresh){ sim.phase='exp'; sim.timeInPhase=0; currentBreath().Ti = sim.t - currentBreath().start; currentBreath().expStart=sim.t; }
    }
  }

  sim.t += sim.dt; sim.timeInPhase += sim.dt;

  const logWinCap = 120; sim.log.push({ t: sim.t, Paw: sim.Paw, Flow: sim.Flow, V: sim.V*1000 });
  while (sim.log.length>0 && (sim.t - sim.log[0].t) > logWinCap) sim.log.shift();
}

// ---------- Cursor helpers ----------
function getSeries(){ return freeze.on ? freeze.data : sim.log; }
function getBreaths(){ return freeze.on ? freeze.breaths : sim.breaths; }
function sampleAt(series, t, key){
  if(!series || series.length<2) return 0;
  let i = series.findIndex(d=> d.t>=t);
  if(i<=0) return series[0][key];
  if(i<0) return series[series.length-1][key];
  const a = series[i-1], b = series[i]; const u = (t - a.t)/Math.max(1e-6, (b.t-a.t));
  return a[key] + (b[key]-a[key])*u;
}

function sliceByTime(series, t0, t1){ return series.filter(d=> d.t>=t0 && d.t<=t1); }
function nearestExtremum(series, key, t, halfWin=0.35){
  const seg = sliceByTime(series, t-halfWin, t+halfWin);
  if(seg.length<3) return t;
  let tMax=seg[0].t, vMax=seg[0][key]; let tMin=tMax, vMin=vMax;
  for(const d of seg){ if(d[key]>vMax){ vMax=d[key]; tMax=d.t; } if(d[key]<vMin){ vMin=d[key]; tMin=d.t; } }
  const vCur = sampleAt(series, t, key);
  const cand = (Math.abs(vCur - vMax) < Math.abs(vCur - vMin)) ? tMax : tMin;
  return cand;
}

// ---------- Drawing (time series & loops) + freeze & crosshair ----------
function draw(){
  [pCan,fCan,vCan].forEach(cv=>{ const r=devicePixelRatio||1; cv.width=cv.clientWidth*r; cv.height=cv.clientHeight*r; const ctx=cv.getContext('2d'); ctx.setTransform(r,0,0,r,0,0); });
  const win = freeze.on ? freeze.win : Math.max(10, Number($('#win').value));
  const series = getSeries(); const breaths = getBreaths();
  const tNow = freeze.on ? freeze.t : sim.t; const tmin = tNow - win; const data = series.filter(d=> d.t>=tmin);
  const PEEPset = (state.mode==='VC-CMV'? state.VC.PEEP : state.mode==='PC-CMV'? state.PC.PEEP : state.PSV.PEEP);

  // Toggle labels based on mode
  if(state.loops.on){
    $('#yP').innerHTML = 'P–V Loop<br><span style="font-size:10px">Paw vs V</span>';
    $('#yF').innerHTML = 'F–V Loop<br><span style="font-size:10px">Flow vs V</span>';
    $('#yV').innerHTML = '';
    $('#rowV').classList.add('hidden');
    $('#pXLabels').classList.add('hidden');
    $('#fXLabels').classList.add('hidden');
  } else {
    $('#yP').innerHTML = 'Pressure<br><span style="font-size:10px">(cmH<sub>2</sub>O)</span>';
    $('#yF').innerHTML = 'Flow<br><span style="font-size:10px">(L/s)</span>';
    $('#yV').innerHTML = 'Volume<br><span style="font-size:10px">(mL)</span>';
    $('#rowV').classList.remove('hidden');
    $('#pXLabels').classList.remove('hidden');
    $('#fXLabels').classList.remove('hidden');
  }

  if(!state.loops.on){
    const pMax = Math.max( (PEEPset)+30, ...data.map(d=>d.Paw+2), 10 );
    const fMax = Math.max( 1, ...data.map(d=>Math.abs(d.Flow)) ) * 1.2;
    const vMax = Math.max( 100, ...data.map(d=>Math.abs(d.V)) ) * 1.2;

    function xMap(t, ctx){ const w=ctx.canvas.clientWidth; return ( (t - tmin) / (win||1) ) * w; }
    function yMap(v, vmin, vmax, ctx){ const h=ctx.canvas.clientHeight; return h - ((v - vmin) / Math.max(1e-6,(vmax - vmin))) * h; }

    function plot(ctx, key, vmin, vmax, color, xlabEl){
      const W=ctx.canvas.clientWidth, H=ctx.canvas.clientHeight;
      ctx.clearRect(0,0,W,H);
      ctx.fillStyle='rgba(255,255,255,.03)'; ctx.fillRect(0,0,W,H);
      ctx.strokeStyle='rgba(255,255,255,.18)'; ctx.lineWidth=1;
      const yTicks=4; for(let i=0;i<=yTicks;i++){ const y= (i/yTicks)*H; ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); const val = lerp(vmax,vmin,i/yTicks); ctx.fillStyle='rgba(255,255,255,.55)'; ctx.font='11px ui-sans-serif'; ctx.fillText(fmt(val, key==='V'?0:0), 4, y-2); }
      const step = Math.max(1, Math.round(win/6));
      for(let t=Math.ceil(tmin); t<=tNow; t+=step){ const x=xMap(t,ctx); ctx.strokeStyle='rgba(255,255,255,.18)'; ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
      if(xlabEl){ xlabEl.innerHTML=''; const n=6; for(let i=0;i<=n;i++){ const tt=tmin + (i/n)*win; const div=document.createElement('div'); div.textContent=fmt(tt - tmin,0)+'s'; xlabEl.appendChild(div);} }

      if(key==='Flow'){ const y0=yMap(0, -fMax, fMax, ctx); ctx.strokeStyle='rgba(255,255,255,.35)'; ctx.beginPath(); ctx.moveTo(0,y0); ctx.lineTo(W,y0); ctx.stroke(); }
      if(key==='V'){ const y0=yMap(0, 0, vMax, ctx); ctx.strokeStyle='rgba(255,255,255,.35)'; ctx.beginPath(); ctx.moveTo(0,y0); ctx.lineTo(W,y0); ctx.stroke(); }

      ctx.strokeStyle=color; ctx.lineWidth=2; ctx.beginPath();
      data.forEach((d,i)=>{ const x = xMap(d.t, ctx); const y = yMap(d[key], vmin, vmax, ctx); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y); }); ctx.stroke();

      if(key==='Paw'){ const yPEEP = yMap(PEEPset, vmin, vmax, ctx); ctx.strokeStyle='rgba(124,156,255,.6)'; ctx.setLineDash([4,4]); ctx.beginPath(); ctx.moveTo(0,yPEEP); ctx.lineTo(W,yPEEP); ctx.stroke(); ctx.setLineDash([]); }

      ctx.strokeStyle='rgba(255,255,255,.25)';
      for(const b of breaths){ if(b.start>=tmin && b.start<=tNow){ const x=xMap(b.start,ctx); ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); } if(b.cycleEnd&&b.cycleEnd>=tmin && b.cycleEnd<=tNow){ const x=xMap(b.cycleEnd,ctx); ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); } }

      // Crosshair & cursor overlays when frozen
      if(freeze.on && freeze.cursor.active){
        let tC = freeze.cursor.t;
        if(freeze.cursor.snap || freeze.cursor.shift) tC = nearestExtremum(series, key, tC, 0.35);
        const x = xMap(tC, ctx);
        const val = sampleAt(series, tC, key); const y = yMap(val, vmin, vmax, ctx);
        // vertical
        ctx.strokeStyle='rgba(255,255,255,.5)'; ctx.setLineDash([3,3]); ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); ctx.setLineDash([]);
        // horizontal
        ctx.strokeStyle='rgba(255,255,255,.35)'; ctx.setLineDash([2,4]); ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); ctx.setLineDash([]);
        // value tag
        ctx.fillStyle='rgba(0,0,0,.45)'; ctx.fillRect(Math.min(Math.max(4,x+6), W-120), 6, 116, 18); ctx.fillStyle='white'; ctx.font='12px ui-sans-serif'; ctx.fillText(fmt(val, key==='V'?0:1) + (key==='Paw'?' cmH2O': key==='Flow'?' L/s':' mL'), Math.min(Math.max(8,x+10), W-116), 19);
      }
    }

    const brand = getComputedStyle(document.documentElement).getPropertyValue('--brand');
    const brand2 = getComputedStyle(document.documentElement).getPropertyValue('--brand2');
    const warn = getComputedStyle(document.documentElement).getPropertyValue('--warn');
    plot(ctxP, 'Paw', 0, Math.max((PEEPset)+30, ...data.map(d=>d.Paw+2), 10 ), brand, $('#pXLabels'));
    plot(ctxF, 'Flow', -Math.max( 1, ...data.map(d=>Math.abs(d.Flow)) ) * 1.2, Math.max( 1, ...data.map(d=>Math.abs(d.Flow)) ) * 1.2, brand2, $('#fXLabels'));
    plot(ctxV, 'V', 0, Math.max( 100, ...data.map(d=>Math.abs(d.V)) ) * 1.2, warn, $('#vXLabels'));

  } else {
    // Loops view
    function clear(ctx){ const W=ctx.canvas.clientWidth, H=ctx.canvas.clientHeight; ctx.clearRect(0,0,W,H); ctx.fillStyle='rgba(255,255,255,.03)'; ctx.fillRect(0,0,W,H); return {W,H}; }
    function drawAxes(ctx, x0, y0, xTicks, yTicks, xLabel, yLabel){
      const {W,H} = {W:ctx.canvas.clientWidth,H:ctx.canvas.clientHeight};
      ctx.strokeStyle='rgba(255,255,255,.25)'; ctx.beginPath(); ctx.moveTo(0,y0); ctx.lineTo(W,y0); ctx.moveTo(x0,0); ctx.lineTo(x0,H); ctx.stroke();
      ctx.fillStyle='rgba(255,255,255,.55)'; ctx.font='11px ui-sans-serif';
      for(const xt of xTicks){ ctx.fillText(xt.label, xt.x, H-4); }
      for(const yt of yTicks){ ctx.fillText(yt.label, 4, yt.y-2); }
      ctx.fillText(xLabel, W-60, H-18); ctx.fillText(yLabel, 6, 14);
    }

    // Get last completed breath segment
    const last = getBreaths().slice(-1)[0];
    let seg = null;
    if(last && last.start!=null){ const t1 = last.cycleEnd ?? tNow; seg = getSeries().filter(d=> d.t>=last.start && d.t<=t1); }
    if(!seg || seg.length<4){ seg = data; }

    // Ranges
    const PawMax = Math.max(10, ...seg.map(d=>d.Paw));
    const Vmax = Math.max(100, ...seg.map(d=>Math.max(0,d.V)));
    const Fabs = Math.max(1, ...seg.map(d=>Math.abs(d.Flow)));

    // P–V loop (Paw vs V)
    (function(){ const {W,H} = clear(ctxP); const pad=28; const xMin=pad, xMax=W-10, yMin=10, yMax=H-16;
      function xMap(v){ return xMin + (Math.max(0,v)/Vmax) * (xMax - xMin); }
      function yMap(p){ return yMax - (p/PawMax) * (yMax - yMin); }
      ctxP.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--brand'); ctxP.lineWidth=2; ctxP.beginPath();
      seg.forEach((d,i)=>{ const x=xMap(d.V); const y=yMap(d.Paw); if(i===0) ctxP.moveTo(x,y); else ctxP.lineTo(x,y); }); ctxP.stroke();
      // Axes & ticks
      const xTicks=[0, Vmax*0.25, Vmax*0.5, Vmax*0.75, Vmax].map(v=>({x:xMap(v)-6,label:(v|0)}));
      const yTicks=[0, PawMax*0.25, PawMax*0.5, PawMax*0.75, PawMax].map(p=>({y:yMap(p),label:fmt(p,0)}));
      drawAxes(ctxP, xMap(0), yMap(0), xTicks, yTicks, 'mL', 'cmH2O'); })();

    // F–V loop (Flow vs V)
    (function(){ const {W,H} = clear(ctxF); const pad=28; const xMin=pad, xMax=W-10, yMin=10, yMax=H-16; const y0 = (yMin+yMax)/2;
      function xMap(v){ return xMin + (Math.max(0,v)/Vmax) * (xMax - xMin); }
      function yMap(f){ return yMax - ((f + Fabs)/(2*Fabs)) * (yMax - yMin); }
      ctxF.strokeStyle=getComputedStyle(document.documentElement).getPropertyValue('--brand2'); ctxF.lineWidth=2; ctxF.beginPath();
      seg.forEach((d,i)=>{ const x=xMap(d.V); const y=yMap(d.Flow); if(i===0) ctxF.moveTo(x,y); else ctxF.lineTo(x,y); }); ctxF.stroke();
      const xTicks=[0, Vmax*0.25, Vmax*0.5, Vmax*0.75, Vmax].map(v=>({x:xMap(v)-6,label:(v|0)}));
      const yTicks=[-Fabs, -Fabs*0.5, 0, Fabs*0.5, Fabs].map(f=>({y:yMap(f),label:fmt(f,1)}));
      drawAxes(ctxF, xMap(0), yMap(0), xTicks, yTicks, 'mL', 'L/s'); })();

    // bottom canvas cleared
    (function(){ const {W,H} = clear(ctxV); ctxV.fillStyle='rgba(255,255,255,.25)'; ctxV.font='12px ui-sans-serif'; ctxV.fillText('Loops view active (P–V top, F–V middle)', 8, 18); })();
  }
}

// Canvas mouse interactions for cursor measurement (time series only)
[pCan,fCan,vCan].forEach(cv=>{
  cv.addEventListener('pointermove', (e)=>{ if(!freeze.on || state.loops.on) return; const rect=cv.getBoundingClientRect(); const x=(e.clientX-rect.left); const frac = clamp(x/rect.width, 0, 1); const win = freeze.win; const tNow = freeze.t; freeze.cursor.t = (tNow - win) + frac*win; freeze.cursor.active=true; });
  cv.addEventListener('pointerleave', ()=>{ if(!freeze.on) return; freeze.cursor.active=false; });
});

// ---------- Metrics & I:E (breath‑measured incl. pause) + Alarms ----------
function computeStats(){
  const windowSec = 60; const series = getSeries(); const breaths = getBreaths();
  const tNow = freeze.on ? freeze.t : sim.t; const t0 = tNow - windowSec;
  const completed = breaths.filter(b=> b.cycleEnd && b.cycleEnd>=t0);
  const FTOT = completed.length * (60/windowSec);
  const last = completed[completed.length-1];

  const VTE = last? (last.VTE*1000) : 0; // mL
  const Ppeak = last? last.Ppeak : 0; const PplatCurrent = (last && last.Pplat!=null)? last.Pplat : lastPplatSeen; const autoPEEP = last? last.autoPEEP : 0;

  let Pmean = 0; if (last){ const seg = series.filter(d=> d.t>=last.start && d.t<=last.cycleEnd); if(seg.length>1){ const dt = (seg[seg.length-1].t-seg[0].t)/(seg.length-1); Pmean = seg.reduce((s,d)=>s+d.Paw*dt,0)/( (seg.length-1)*dt ); } }

  const VEmLmin = completed.reduce((sum,b)=> sum + b.VTE*1000, 0) * (60/windowSec); const VE = VEmLmin/1000;

  // I:E from measured timings; inspiratory time includes pause (start -> expStart)
  let IEratio = '—', Ti=0, Te=0, Total=0, Pause=0;
  if(last && last.cycleEnd && last.expStart){
    Total = Math.max(0.05, last.cycleEnd - last.start);
    const TiPure = last.Ti||Math.max(0.05, last.expStart - last.start); // fallback
    const TiInclPause = Math.max(0.05, last.expStart - last.start);
    Pause = Math.max(0, TiInclPause - TiPure);
    Ti = TiInclPause;
    Te = Math.max(0.05, Total - Ti);
    // Requested formatting: normally I=1 part; if inverse (Ti>Te), set E=1 and I>1
    if(Ti>0 && Te>0){
      if(Ti <= Te){ IEratio = `1:${fmt(Te/Ti,1)}`; }
      else { IEratio = `${fmt(Ti/Te,1)}:1`; }
    }
  }
  $('#ieVal').textContent = IEratio;

  // I:E average over last 5 completed breaths (format with same rule)
  const recent = completed.slice(-5);
  let IEavg = '—';
  if(recent.length){
    let sumTi=0, sumTe=0, n=0; for(const b of recent){ if(b.cycleEnd && b.expStart){ const TT = Math.max(0.05, b.cycleEnd - b.start); const TI = Math.max(0.05, b.expStart - b.start); sumTi+=TI; sumTe+=Math.max(0.05, TT-TI); n++; } }
    if(n>0){ const mTi=sumTi/n, mTe=sumTe/n; IEavg = (mTi <= mTe) ? `1:${fmt(mTe/mTi,1)}` : `${fmt(mTi/mTe,1)}:1`; }
  }

  const ieList = [
    {k:'Inspiratory Time incl. pause', v: fmt(Ti,2), u:'s'},
    {k:'Pause (inspiratory hold)', v: fmt(Pause,2), u:'s'},
    {k:'Expiratory Time', v: fmt(Te,2), u:'s'},
    {k:'Cycle Time', v: fmt(Total,2), u:'s'},
    {k:'I:E (last breath)', v: IEratio, u:''},
    {k:'I:E (avg last 5)', v: IEavg, u:''}
  ];
  const diag = $('#ieDiag'); diag.innerHTML='';
  for(const s of ieList){ const div=document.createElement('div'); div.className='stat'; div.innerHTML = `<div class=\"k\">${s.k}</div><div class=\"v\">${s.v} <span class=\"unit\">${s.u}</span></div>`; diag.appendChild(div); }

  const list = [
    {k:'Peak Airway Pressure', abb:'(PPEAK)', v: fmt(Ppeak,1), u:'cmH2O'},
    {k:'Plateau Pressure', abb:'(PPL)', v: (PplatCurrent!=null? fmt(PplatCurrent,1):'—'), u:'cmH2O'},
    {k:'Mean Airway Pressure', abb:'(PMEAN)', v: fmt(Pmean,1), u:'cmH2O'},
    {k:'Exhaled Tidal Volume', abb:'(VTE)', v: fmt(VTE,0), u:'mL'},
    {k:'Minute Ventilation', abb:'(VE TOT)', v: fmt(VE,1), u:'L/min'},
    {k:'Frequency Total', abb:'(FTOT)', v: fmt(FTOT,1), u:'Breaths/min'},
    {k:'I : E', abb:'(I:E)', v: IEratio, u:''},
    {k:'Intrinsic PEEP', abb:'(Auto‑PEEP)', v: fmt(autoPEEP,1), u:'cmH2O'}
  ];
  const stats = $('#stats'); stats.innerHTML='';
  for (const s of list){ const div=document.createElement('div'); div.className='stat'; div.innerHTML = `<div class=\"k\">${s.k} <span class=\"unit\">${s.abb}</span></div><div class=\"v\">${s.v} <span class=\"unit\">${s.u}</span></div>`; stats.appendChild(div); }

  updateAlarms({ Ppeak, VTE, FTOT, VE, tNow, last });
}

// ---------- Alarms ----------
const alarmUI = { bar: $('#alarmBar'), text: $('#alarmText'), silenceBtn: $('#silenceBtn') };
const beeper = { ctx:null, gain:null, lastBeep:0, silencedUntil:0 };

function ensureAudio(){ if(beeper.ctx) return; const AudioCtx = window.AudioContext || window.webkitAudioContext; if(!AudioCtx) return; beeper.ctx = new AudioCtx(); beeper.gain = beeper.ctx.createGain(); beeper.gain.gain.value = 0.0; beeper.gain.connect(beeper.ctx.destination); }
function beepOnce(){ if(!beeper.ctx) return; const nowa = beeper.ctx.currentTime; const o = beeper.ctx.createOscillator(); o.type='square'; o.frequency.value=880; o.connect(beeper.gain); beeper.gain.gain.setValueAtTime(0.0, nowa); beeper.gain.gain.linearRampToValueAtTime(0.18, nowa+0.01); beeper.gain.gain.linearRampToValueAtTime(0.0, nowa+0.22); o.start(nowa); o.stop(nowa+0.24); }

document.addEventListener('pointerdown', ()=>{ try{ ensureAudio(); beeper?.ctx?.resume(); }catch{} }, {once:true});
alarmUI.silenceBtn.addEventListener('click', ()=>{ beeper.silencedUntil = now() + 60; updateAlarmBar([], 'silenced'); });

function updateAlarmBar(names, stateName){
  alarmUI.bar.classList.remove('ok','active','silenced');
  if(stateName==='silenced'){ alarmUI.bar.classList.add('silenced'); alarmUI.text.textContent = names.length? names.join(' • ') + ' — silenced 60s' : 'Silenced'; return; }
  if(names.length===0){ alarmUI.bar.classList.add('ok'); alarmUI.text.textContent=''; return; }
  alarmUI.bar.classList.add('active'); alarmUI.text.textContent = names.join(' • ');
}

function updateAlarms(m){
  const names = [];
  const A = state.alarms;
  if(m.last){
    if(A.highPpeak>0 && m.Ppeak > A.highPpeak) names.push('High PPEAK');
    if(A.highVte>=30 && m.VTE > A.highVte) names.push('High VTE');
    if(A.lowVte>=5 && m.VTE < A.lowVte) names.push('Low VTE');
  }
  if(A.highFtot>=10 && m.FTOT > A.highFtot) names.push('High FTOT');
  if(A.lowVe>=0 && m.VE < A.lowVe) names.push('Low VE TOT');
  if(A.apnea>0){
    const recent = getBreaths().filter(b=> (m.tNow - b.start) <= A.apnea);
    if(recent.length===0) names.push('Apnea');
  }

  // Audio + UI
  const isActive = names.length>0;
  if(isActive){
    const silenced = now() < beeper.silencedUntil;
    updateAlarmBar(names, silenced? 'silenced':'active');
    if(!silenced){ ensureAudio(); try{ beeper?.ctx?.resume(); }catch{}; if(now() - beeper.lastBeep > 1.0){ beepOnce(); beeper.lastBeep = now(); } }
  } else {
    updateAlarmBar([], 'ok');
  }
}

// ---------- Main Loop ----------
function loop(){
  const realNow = now(); let acc = realNow - tPrev; acc = Math.min(acc, 0.2);
  while (acc >= sim.dt){ simStep(); acc -= sim.dt; }
  tPrev = realNow - acc;
  try { draw(); computeStats(); } catch (e) { console.error('Render error:', e); }
  requestAnimationFrame(loop);
}

// Initialize
sim.cycleStart = 0; sim.phase='exp';
startNewBreath();
loop();

</script>
</body>
</html>
